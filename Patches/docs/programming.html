<!DOCTYPE html []>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="author" content="MarkdownViewer++" />
    <title>programming.md</title>
    <style type="text/css">
            
/* Avoid page breaks inside the most common attributes, especially for exports (i.e. PDF) */
td, h1, h2, h3, h4, h5, p, ul, ol, li {
    page-break-inside: avoid; 
}
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body &gt; *:first-child {
  margin-top: 0 !important; }
body &gt; *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url("../../images/modules/styleguide/para.png") no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url("../../images/modules/pulls/dirty-shade.png") repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0; }

body &gt; h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body &gt; h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body &gt; h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body &gt; h3:first-child, body &gt; h4:first-child, body &gt; h5:first-child, body &gt; h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }

ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

ul :last-child, ol :last-child {
  margin-bottom: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt &gt; :first-child {
      margin-top: 0; }
    dl dt &gt; :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd &gt; :first-child {
      margin-top: 0; }
    dl dd &gt; :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote &gt; :first-child {
    margin-top: 0; }
  blockquote &gt; :last-child {
    margin-bottom: 0; }

table {
  padding: 0; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame &gt; span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center &gt; span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right &gt; span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right &gt; span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; } \n
        </style>
  </head>
  <body>
    <p>
      <em>This document is still work in progress and any help would be appreciated!</em>
    </p>
    <h1 id="programming">Programming</h1>
    <p>Unlike the first version of the SA-1 PATCH, this one
is much more complex because of the various RAM remapping,
not counting the whole new ROM mapping (SA-1 ROM).</p>
    <p>In other words, in order to making anything SA-1
compatible, you will need to change:</p>
    <p>(assuming that XX is in the <code>$00</code>-<code>$3F</code> or <code>$80</code>-<code>$BF</code> range
and YY equals either XX or <code>$7E</code>)</p>
    <p>
      <code>$YY:0000</code>-<code>$YY:00FF</code> to <code>$XX:3000</code>-<code>$XX:30FF</code>.<br /><code>$YY:0100</code>-<code>$YY:1FFF</code> to <code>$XX:6100</code>-<code>$XX:7FFF</code>.</p>
    <p>Note that if you're using 16-bit addressing,
you should to use <code>$3000</code>-<code>$30FF</code> and <code>$6100</code>-<code>$7FFF</code> for that.
8-bit addresses should work fine since DP is set to <code>$3000</code>.</p>
    <p>
      <code>$7E:C800</code>-<code>$7E:FFFF</code> to <code>$40:C800</code>-<code>$40:FFFF</code>.<br /><code>$7F:C800</code>-<code>$7E:FFFF</code> to <code>$41:C800</code>-<code>$41:FFFF</code>.</p>
    <p>
      <code>$7F:9A7B</code>-<code>$7F:9C7A</code> to <code>$41:8800</code>-<code>$41:89FF</code>.</p>
    <p>
      <code>$70:0000</code>-<code>$70:07FF</code> to <code>$41:C000</code>-<code>$41:C7FF</code>.</p>
    <p>Also, note that <code>$70:0800</code>-<code>$70:27FF</code> is now
<code>$41:A000</code>-<code>$41:BFFF</code> if you want more SRAM, but only that
much. 16 KB should be enough for SRAM unless you're working
on something that really wastes space. Alternatively, you
can use MarioE/LX5's BW-RAM plus patch, which makes the job
easier.</p>
    <p>For more information, see the Memory Map Summary file
located in docs folder. It also contains information about
the remapped sprite tables, which will likely cause problem
if you don't use a special remapping for them.</p>
    <p>Now, knowing all the SRAM/RAM mapping changes, you may
ask: what is the data at <code>$40:0000</code>-<code>$41:FFFF</code>
and <code>$XX:3000</code>+ for?</p>
    <p>When you activate SA-1, two types of RAM are added
and one is deleted. In other words, I-RAM and BW-RAM
are added while SRAM is deleted.</p>
    <p>I-RAM is SA-1 Internal RAM, which is why it's called I-RAM.
The I-RAM runs at 10.74 MHz with no delay and is the
fastest RAM of SNES, with exception of Super FX's cache.
But since cache isn't RAM, that doesn't count.
The size of I-RAM is 2 KB (2048 bytes) and it's
located in banks <code>$00</code>-<code>$3F</code> and <code>$80</code>-<code>$BF</code>, in the
<code>$3000</code>-<code>$37FF</code> range.</p>
    <p>
      <code>$3000</code>-<code>$30FF</code> is same as <code>$7E:0000</code>-<code>$7E:00FF</code> on SMW,
which increases the read/write speed by 4 times.
The game will access it even when running code from the
SNES side, because the Direct Page is now at <code>$3000</code>.</p>
    <p>
      <code>$3100</code>-<code>$31FF</code> is internally used by my patch for
various purposes.</p>
    <p>
      <code>$3200</code>-<code>$3425</code> is used by Arujus's more sprites patch!<br /><code>$3426</code>-<code>$36FF</code> is free to use.<br /><code>$3700</code>-<code>$377F</code> is the Character Conversion DMA buffer.<br /><code>$3780</code>-<code>$37FF</code> is the SA-1 stack.</p>
    <p>A detailed I-RAM map is included on docs\I-RAM.txt</p>
    <p>I-RAM is recommended to be used for RAM codes or as a place
for storing data which is accessed many times, since it'll
be accessed much faster than other type of RAM.</p>
    <p>BW-RAM is SA-1's SRAM. As simple as that. But unlike the
SRAM (which means Static or Saveable RAM), BW-RAM means
Backup and Work RAM. In other words, BW-RAM is a
RAM created for both working and saving. I don't think
its purposes change that much, but could BW-RAM be a little
faster than SRAM..? I don't know.</p>
    <p>BW-RAM runs at 5.37 MHz and is mapped to banks <code>$40</code>-<code>$4F</code>.
You can expand the BW-RAM size to 256 KB, according to the
SNES Dev. Manual Book II, but I only got up to 128 KB working,
perhaps because none of the emulators implemented that, or
no SA-1 game ever used 256 KB of BW-RAM.</p>
    <p>This patch always uses the maximum BW-RAM size possible
(128 KB) in banks <code>$40</code>-<code>$41</code>. <code>$42</code>-<code>$FF</code> will mirror the first two
banks (e.g <code>$42</code> and <code>$40</code>, <code>$43</code> and <code>$41</code>, etc).</p>
    <p>I remapped most RAM on SMW to BW-RAM and the SRAM of course.
For more details, check docs\BW-RAM.txt</p>
    <p>Of course, if the BW-RAM is at bank <code>$40</code>+ now, where has the
ROM been moved to?</p>
    <p>The ROM map changed in rather complex way. Look:</p>
    <table>
      <thead>
        <tr>
          <th>Bank Range</th>
          <th>Content</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <code>$00</code>-<code>$1F</code></td>
          <td>ROM (CXB) (LoROM)</td>
        </tr>
        <tr>
          <td>
            <code>$20</code>-<code>$3F</code></td>
          <td>ROM (DXB) (LoROM)</td>
        </tr>
        <tr>
          <td>
            <code>$40</code>-<code>$4F</code></td>
          <td>BW-RAM</td>
        </tr>
        <tr>
          <td>
            <code>$50</code>-<code>$5F</code></td>
          <td>Unmapped</td>
        </tr>
        <tr>
          <td>
            <code>$60</code>-<code>$6F</code></td>
          <td>(SA-1 only) "Virtual" BW-RAM.</td>
        </tr>
        <tr>
          <td>
            <code>$70</code>-<code>$7D</code></td>
          <td>Unmapped</td>
        </tr>
        <tr>
          <td>
            <code>$7E</code>-<code>$7F</code></td>
          <td>(SNES only) WRAM/Work RAM</td>
        </tr>
        <tr>
          <td>
            <code>$80</code>-<code>$9F</code></td>
          <td>ROM (EXB) (LoROM)</td>
        </tr>
        <tr>
          <td>
            <code>$A0</code>-<code>$BF</code></td>
          <td>ROM (FXB) (LoROM)</td>
        </tr>
        <tr>
          <td>
            <code>$C0</code>-<code>$CF</code></td>
          <td>ROM (CXB) (HiROM)</td>
        </tr>
        <tr>
          <td>
            <code>$D0</code>-<code>$DF</code></td>
          <td>ROM (DXB) (HiROM)</td>
        </tr>
        <tr>
          <td>
            <code>$E0</code>-<code>$EF</code></td>
          <td>ROM (EXB) (HiROM)</td>
        </tr>
        <tr>
          <td>
            <code>$F0</code>-<code>$FF</code></td>
          <td>ROM (FXB) (HiROM)</td>
        </tr>
      </tbody>
    </table>
    <p>Now the ROM is split into various locations, which
may act as LoROM or HiROM, and each part has an "ID", which
can be CXB, DXB, EXB or FXB. Those belong to the ROM area,
and their content may vary depending on what the bank switch
value is, which is set using the SA-1 registers <code>$2220</code>-<code>$2223</code>.
But my patch already takes care of that.</p>
    <p>If the ROM is 4 MB or less, <code>$00</code>-<code>$3F</code> and <code>$80</code>-<code>$BF</code> will map to
the 1st&amp;2nd MB and the 3rd&amp;4th MB respectively. <code>$C0</code>-<code>$FF</code> will be
the HiROM area mirroring the same 4MB of data.</p>
    <p>If the ROM is 5-8MB, the first 4MB are mapped to <code>$00</code>-<code>$3F</code> and <code>$80</code>-<code>$BF</code>
and the last 4MB of the ROM are mapped to <code>$C0</code>-<code>$FF</code>. Yeah, that will
make the first 4MB LoROM only and the last 4MB HiROM only.
This way you can access all the 8MB at once, though some emulators
may have some problems with it.</p>
    <p>This also means that FastROM addressing will not work, so pay
attention to any strange jump to the <code>$808000</code>+ area, and subtract
<code>$800000</code> from those.</p>
    <p>Xkas doesn't support SA-1 mapping and because of that you'll
be fine using it only for patching in the first 2MB area.</p>
    <p>You can try using <code>org $408000</code> or <code>org $C00000</code> with <code>base $808000</code>,
but xkas doesn't really like the base command that much.</p>
    <p>Using Asar, you can access all the SA-1 data, but you will need to
switch the mapping every time you're accessing an area outside
of the current range.</p>
    <p>Example:</p>
    <pre>
      <code class="language-asm">sa1rom 0,1,2,3 ; access the first 4MB

org $018000 ; hijack something
	JSL CustomCode ; and run the custom code...

sa1rom 4,5,6,7

org $C00000
CustomCode: ;*put code here*;
	RTL
</code>
    </pre>
    <p>However freecode/freedata will not work with Asar when you are
accessing the 4MB+ area, atleast until Alcaro adds "bigsa1rom"
to Asar (if he hasn't implemented it already).</p>
    <hr />
    <p>Now that you know how the memory (ROM/RAM) works,
you may ask: How can I invoke SA-1?</p>
    <p>Going into SA-1 mode is really easy.
Store the 24-bit address to jump to into <code>$3180</code>-<code>$3182</code> and
then <code>JSR</code> to <code>$1E80</code>, i.e.:</p>
    <pre>
      <code class="language-asm">LDA.b #Label				; \ Put the address
STA $3180				;  | to jump in
LDA.b #Label&gt;&gt;8				;  | $3180 - $3182.
STA $3181				;  |
LDA.b #Label&gt;&gt;16			;  |
STA $3182				; /
JSR $1E80				; Invoke SA-1 and wait to finish.
[...]					; *other code*

Label:
PHB					; \ Set Bank
PHK					;  |
PLB					; /
; *The SA-1 CPU runs here.*
PLB					; Restore Bank
RTL					; Return.
</code>
    </pre>
    <p>So if you wanted to jump to the address <code>$00974C</code>, you'd do this:</p>
    <pre>
      <code class="language-asm">LDA #$4C				; \ Low
STA $3180				; /
LDA #$97 				; \ High
STA $3181				; /
LDA #$00				; \ Bank (in this case STZ $3182 would work better)
STA $3182 				; /
JSR $1E80				; Invoke SA-1
</code>
    </pre>
    <p>You can do multi-threaded operation too:</p>
    <pre>
      <code class="language-asm">LDA.b #Label				; \ Put the address
STA $3180				;  | to jump in
LDA.b #Label&gt;&gt;8				;  | $3180 - $3182.
STA $3181				;  |
LDA.b #Label&gt;&gt;16			;  |
STA $3182				; /
LDA #$80				; \ Invoke SA-1
STA $2100				; /
; Do stuff while SA-1 is executing Label.
JSR $1E85				; Wait SA-1 if it didn't finished its operation.
[...]					; *other code*

Label:
PHB					; \ Set Bank
PHK					;  |
PLB					; /
; *The SA-1 CPU runs here.*
PLB					; Restore Bank
RTL					; Return.
</code>
    </pre>
    <p>This operation may be really useful, but be careful that if
you access the ROM in multi-threading mode, SA-1 may access
it at 5.37 MHz, decreasing processing speed.</p>
    <p>To make sure that SA-1 will run at full speed, place the code
in WRAM and run it from there instead.</p>
    <p>When you switch to SA-1 side, the system works a bit differently:</p>
    <ul>
      <li>
        <p>You can't access the PPU and CPU registers,
which are located at <code>$2100</code>-<code>$21FF</code>, <code>$4200</code>-<code>$42FF</code> and around <code>$4000</code> too.</p>
      </li>
      <li>
        <p>You can't access WRAM (Work RAM) in banks <code>$7E</code> and <code>$7F</code>.
Also <code>$0000</code>-<code>$07FF</code> are mapped to I-RAM instead, while
<code>$0800</code>-<code>$1FFF</code> is unused.</p>
      </li>
      <li>
        <p>You can access the <code>$600000</code>-<code>$6FFFFF</code> range, which is the "Virtual"
BW-RAM.</p>
      </li>
      <li>
        <p>The CPU runs 4x times faster than usual, specifically at 10.74 MHz
instead of 2.68 or 3.56 MHz (FastROM).</p>
      </li>
    </ul>
    <p>Since you can't access the other CPU registers, you'd think to be
unable to do DMA and Multiplication/Division, right? FALSE! You'll be
able to use the SA-1 registers located at <code>$2200</code>-<code>$23FF</code>!</p>
    <p>Plus the Multiplication and DMA registers available using SA-1
are much faster than the SNES ones. But you can't DMA to VRAM or
any other PPU register, since while on SA-1 side, you can only access
the cart contents (ROM, BW-RAM, I-RAM and SA-1 Registers).</p>
    <p>To execute a multiplication, do this:</p>
    <pre>
      <code class="language-asm">LDA #$00				; \ Set Multiplication Mode.
STA $2250				; /

REP #$20				; 16-bit Accum
LDA #$XXXX 				; \ Set first multiplicand
STA $2251				; /
LDA #$YYYY 				; \ Set second multiplicand
STA $2253				; /

NOP     				; \ ... Wait 5 cycles!
BRA $00 				; /

; Then can you read the product from $2306, $2307, $2308 and $2309.
; Yes, the product of SA-1 Multiplication is 32-bit! Awesome, isn't it?
; While in SNES it's 8-bit x 8-bit = 16-bit, in SA-1 it is
; 16-bit x 16-bit = 32-bit. And you only need to wait 5 cycles
; which is ~62% of a NOP in SNES!
</code>
    </pre>
    <p>To execute a division, do this:</p>
    <pre>
      <code class="language-asm">LDA #$01				; \ Set Division Mode
STA $2250 				; /

REP #$20				; 16-bit Accum
LDA #$XXXX				; \ Set dividend
STA $2251				; /
LDA #$YYYY				; \ Set divisor
STA $2253				; /

NOP     				; \ ... Wait 5 cycles!
BRA $00 				; /

; Then you can read the division result from $2306 &amp; $2307
; and the remainder from $2308 &amp; $2309
</code>
    </pre>
    <p>Other enhancement chips may work like a slave, because the
SNES sends a command to the chip, which then sends back the
result. But with SA-1 is different story, since both chips
can have interrupts so there's no slave in this case!</p>
    <p>How can this be useful? When you can't access something from SA-1 side,
of course. Using this method, you can make a quick access on something
from SNES side, then come back with the value. Example: SA-1 wants to
read from an APU port, but it can't access it. To make it accessible,
call the the SNES so you can read from the APU port and then send
the value to SA-1. See below:</p>
    <pre>
      <code class="language-asm">LDA.B #.SNES				; \ Put the SNES pointer to run
STA $0183				; | in $0183-$0185.
LDA.B #.SNES/256			; |
STA $0184				; | (Remember that $0000-$07FF
LDA.B #.SNES/65536			; |  is same as $3000-$37FF).
STA $0185				; /
LDA #$D0				; \ Invoke/Call SNES
STA $2209				; /
.Wait					; \ Wait for SNES.
LDA $018A				; |
BEQ .Wait				; |
STZ $018A				; /
; Now APU value is at $0100-$0103, because:

.SNES					; SNES code
;PHB					; \ Set Bank (not really required to access RAM)
;PHK					; |
;PLB					; /
LDA $2140				; \ Read $2140-$2143
STA $3100				; | and save in $3100-$3103
LDA $2141				; | (Remember that $0000-$07FF is
STA $3101				; | NOT same as $3000-$37FF in SNES!)
LDA $2142				; |
STA $3102				; |
LDA $2143				; |
STA $3103				; /
;PLB					; Restore Bank
RTL					; Return.
</code>
    </pre>
    <p>Using said method you can get rid of almost all SA-1
limitations, but remember that the SNES's speed is 2 MHz,
so if you call it too many times, you may waste some time.</p>
    <p>Additionally, there's a special mode called Parallel/Background Mode.
It runs a certain code periodically while the SA-1 CPU is idle.</p>
    <p>To enable it, put the code pointer to <code>$3186</code>-<code>$3188</code> and set <code>$318B</code> to <code>#$01</code>.
Unlike other modes, you have to threat this one differently:</p>
    <ol>
      <li>
        <p>You must reserve a RAM area to use it, since other code can potentially
use it at any time. In other words, you can't use the standard RAM addresses
or your RAM writes will end up corrupted when another code gets executed by
the chip or even by SNES CPU. For these reasons, I reserved 32 bytes at
<code>$31E0</code>-<code>$31FF</code> just for Parallel Mode, so you can put your scratch values without
having risk of it getting corrupted suddenly.</p>
      </li>
      <li>
        <p>Direct Page is set to <code>$0100</code>, since you usually will not access standard
direct page area (<code>$3000</code>-<code>$30FF</code>) and with that you will have facility with
accessing Parallel Mode reserved RAM as well other SA-1 Pack internal RAM
addresses. Of course after running your code, you should restore it back
to <code>$0100</code> if you changed it. Oh and if you're wondering, in the <strong>SA-1 CPU</strong>,
<code>$0100</code> is same thing as <code>$3100</code>. Don't get confused.</p>
      </li>
      <li>
        <p>When accessing registers (or any other not thread-safe address), you must
disable IRQ (by using SEI opcode), to stop SA-1 from listening from SNES CPU.
With that, you can access the multiplications registers or execute a DMA
without having the risk of it getting conflicted by another thread. Don't forget
to use CLI to re-enable IRQ or otherwise the game will freeze.</p>
      </li>
      <li>
        <p>Is preferred to your code work rather as a service, which runs code on demand.
This mode is useful for code that does, for example, graphics manipulation so it
won't access in-game performance because it ONLY uses SA-1 idle cycles and when
the game code is running its code gets paused.</p>
      </li>
      <li>
        <p>If the status flag (318B) is set to <code>#$FF</code>, the service MUST stop current
operations and gets free to an another parallel service start executing. Because
obviously only one parallel mode code can be ran at once (I may change that in the
future but I don't think it will be ever needed).</p>
      </li>
    </ol>
    <p>Example code (invoking parallel mode):</p>
    <pre>
      <code class="language-asm">	LDA $318B		; \ If there's no Parallel Mode running already,
	BEQ +			; / skip.

	LDA #$FF		; \ Tell previous Parallel Mode code to exit.
	STA $318B		; / This is important or the game may crash or stop working.

-	LDA $318B		; \ Wait until the previous server gets free.
	BNE -			; /

+
	LDA.b #MyCode		; \ Place Parallel Mode Service Pointer
	STA $3186		;  |
	LDA.b #MyCode&gt;&gt;8	;  |
	STA $3187		;  |
	LDA.b #MyCode&gt;&gt;16	;  |
	STA $3188		; /

	LDA #$01		; \ Start Parallel Mode Service
	STA $318B		; /
</code>
    </pre>
    <p>Example code (actual parallel mode):</p>
    <pre>
      <code class="language-asm">	PHB			; \ Set up banks.
	PHK			;  |
	PLB			; /

.main_loop
	LDA $8B			; \ If the parallel mode state
	CMP #$FF		;  | is set to #$FF (end), shutdown
	BEQ .end		; / the service.

	LDA $EF			; \ Check if there's any graphics
	CMP $EE			;  | rotation request.
	BEQ .main_loop		;  |
	STA $EF			; /

	JSR .rotate		; Rotate GFX (not included there)
	BRA .main_loop		; Go to back main loop.

.end
	PLB			; Restore bank
	RTL			; Return.
</code>
    </pre>
    <p>Personally this mode is extremely useful for rotating graphics, because
it takes SA-1's unused cycles and it does not cause slowdown. If there's
not enough time to rotate a GFX, instead of making the game get unstable
and slowdown, it will just reduce the rotation frame rate, which most
users will not actually notice. It can be also useful for you, for some
reason, want to for example decompress a GFX in the background without
freezing temporally the level or even you want to run a music engine
here. Use it freely! Remember that it's multi-threaded and your code
must be thread-safe with normal SA-1 operations and with the SNES CPU.
And when SNES CPU code is running together with Parallel Mode, the code
performance may reduce a bit to around 8 MHz, but still a very good
performance to explore while SA-1 CPU is not doing anything. And when
SNES is idle (i.e. finished processing a game frame), the code is
executed normally at 10.74 MHz.</p>
    <p>There are a bunch of other useful features too, such as bit stream
and fast DMA which are only available while on SA-1 side.</p>
    <p>The SA-1 DMA can transfer data from ROM to I-RAM (10 MHz (4x faster than SNES)),
from ROM to BW-RAM (5 MHz (2x faster)), from BW-RAM to I-RAM (5 MHz (2x faster))
and from I-RAM to BW-RAM (5 MHz (2x faster)). Although I-RAM &lt;-&gt; BW-RAM transfers
are 2x slower than ROM -&gt; I-RAM ones, you can still run SA-1 and DMA in parallel.</p>
    <p>SA-1 DMA example (ROM-&gt;BW-RAM):</p>
    <pre>
      <code class="language-asm">LDA.b #%11000100 			; \ Enable DMA, DMA Priority, ROM-&gt;BWRAM
STA $2230				; /

REP #$20				; 16-bit Accum
LDA #Location 				; \ ROM source address
STA $2232				; /
LDX #Bank 				; \ ROM source bank
STX $2234				; /

LDA #Size				; \ Set size of transfer
STA $2238				; /

LDA #Dest				; \ BW-RAM destination address
STA $2235				; /
LDX #BWRAM_Bank				; \ BW-RAM destination bank (#$40 or #$41)
STX $2237				; / The DMA starts upon writing to $2237.
; Note that if the destination is I-RAM, then it'll start upon writing to $2236 instead.

.Wait
LDX $318C				; \ Wait for DMA flag.
BEQ .Wait				; /
LDX #$00				; \ Clear the DMA flag
STX $318C 				; /
STX $2230				; Disable SA-1 DMA

SEP #$20 				; 8-bit Accum
</code>
    </pre>
    <p>Although I only used the Variable Length Bit Processing (bit stream)
feature once, here is an example how to use it (In Fixed Mode):</p>
    <pre>
      <code class="language-asm">STZ $2258				; Set Fixed Mode

REP #$20				; \ Set the address to start reading from
LDA #$Address				;  |
STA $2259				;  |
LDX #$Bank				;  |
STX $225B				;  |
SEP #$20				; /

; Now let me explain. $2306 and $2307 contain
; a virtually "infinite" value from ROM
; that you can read (only 16-bit at once)
; and shift by the desired amount of bits to the right.

; To make a little easier, imagine that $2258 is a seek function, but it uses bits instead of bytes,
; and $230C/$230D is a read function, but without seek if fixed mode is used.
; It works like this:
</code>
    </pre>
    <pre>
      <code class="language-csharp">bitStream bs = new BitStream(romData); 		// romData is a byte array.

int someBits = bs.ReadByte() &amp; 0x0F;		// read 4 bits
bs.Seek(4);					// seek / shift 4 bits

int moreBits = bs.ReadByte() &amp; 0x07;		// read 3 bits
bs.Seek(3);					// seek / shift 3 bits
</code>
    </pre>
    <p>The code above, translated into ASM, would look like this:</p>
    <pre>
      <code class="language-asm">LDA $230C
AND #%BitsToMask
[handle value]
LDA #$BitsToSeek
STA $2258
</code>
    </pre>
    <p>You can keep doing this until you want to stop the reading process.</p>
    <p>Here's a simple practical example.
In LZ2, the syntax of the header looks like this (in bits):</p>
    <pre>
      <code>bits
76543210
CCCLLLLL

CCC:   Command bits
LLLLL: Length
</code>
    </pre>
    <p>So <code>CCC</code> is the command and <code>LLLLL</code> is the length.
To read that using bit stream, you can do this:</p>
    <pre>
      <code class="language-asm">LDA $230C
AND #%00011111
; Handle length value
LDA #$05
STA $2258 ; Seek 5 bits, now CCCLLLLL -&gt; ?????CCC

LDA $230C
AND #%00000111
; Handle command value
LDA #$03 ; Shift 3 bits now ?????CCC -&gt; ????????
STA $2258

; Do stuff and/or keep reading, etc.
</code>
    </pre>
    <p>Well, that was all I could do about examples. Now have fun combinating
all features!</p>
    <p>WARNING: bsnes 0.7x appears to have a bug with the bit stream, as the bank
switching doesn't work while using the Variable Length Bit feature,
thus making it impossible to access the 5-8MB area. Be careful!</p>
    <p>Now, there's still one feature that I haven't explained yet, so it's time to
explain it, I guess. I said earlier that SA-1 can access banks <code>$60</code>-<code>$6F</code>,
aka the "Virtual" BW-RAM, right?</p>
    <p>The "Virtual" BW-RAM (I'll name as VRAM, okay?) is a BW-RAM mirror, but with a
special added feature. The special feature of this area is that it only stores
certain bits to the actual BW-RAM: 4 or 2 bits, depending on the value in <code>$223F</code>.
If bit 7 of that one is clear, the VRAM will write 4 bits, otherwise only 2 bits
are used from each address. It basically works like this:</p>
    <pre>
      <code class="language-c">$40:0000 = ($60:0000 &lt;&lt; 0) | ($60:0001 &lt;&lt; 4);
</code>
    </pre>
    <p>Or if bit <code>7</code> of <code>$223F</code> is set:</p>
    <pre>
      <code class="language-c">$40:0000 = ($60:0000 &lt;&lt; 0) | ($60:0001 &lt;&lt; 2) | ($60:0002 &lt;&lt; 4) | ($60:0003 &lt;&lt; 6);
</code>
    </pre>
    <p>Similarly, in order to write to <code>$40:0001</code>, you'll need to use both <code>$60:0002</code>
and <code>$60:0003</code> if bit 7 of <code>$223F</code> is clear, or else you'll want <code>$60:0004</code>, <code>$60:0005</code>,
<code>$60:0006</code> and <code>$60:0007</code>.</p>
    <p>So, if you write <code>#$0F</code> to <code>$60:0000</code>, it'll do:</p>
    <pre>
      <code class="language-asm">LDA $400000
AND #$F0
ORA $600000
STA $400000
</code>
    </pre>
    <p>then, if <code>$60:0001</code> is written:</p>
    <pre>
      <code class="language-asm">LDA $600001
AND #$0F
ASL #4
STA $00
LDA $400000
AND #$0F
ORA $00
STA $400000
</code>
    </pre>
    <p>and if bit 7 of <code>$223F</code> is set, it'll work similarly,
but with <code>$60:0000</code>-<code>$60:0003</code> and using 2 bits from each address.</p>
    <p>Of course, making use of this VRAM will speed up the process of storing
a few bits to a RAM address, but why would we use this?
For the one and only reason: Character Conversion DMA.</p>
    <p>But what is Character Conversion DMA?
You know, some games managed to use get some pretty nice effects such as rotating, scaling...
But you can't do that directly in SNES file format, because it's a bit too complex
to change its pixels.</p>
    <p>To work around that, you will need to create a linear bitmap in RAM, then set all
the pixels and effects and convert the data into SNES format to store it into VRAM.
But the conversion is really tricky and to help that, SA-1 has a really great feature,
which happens to be the most complex DMA available, used to convert bitmaps into SNES
format and AT SAME TIME upload it in VRAM. This is done thanks to a combination of 2 DMAs,
the SNES DMA and SA-1 DMA. While the SNES DMA reads the BW-RAM and transfers data from
it to VRAM, the SA-1 DMA reads from BW-RAM, converts the data to SNES format and "gives"
to SNES, bypassing the value that the SNES reads from BW-RAM. All of this is done at the
same time and during NMI. So with Character Conversion DMA you can make a Framebuffer in
BW-RAM and upload into VRAM in a very easy and fast way, since the transfers will still
take the same time: 1 cycle per byte, except that SA-1 DMA converts the data simultaneously.</p>
    <p>Fortunately, I've already accomplished the harder tasks and my patch already handles
Character Conversion DMA for you.
I created a table, which works much more like the OAM/Sprite Tiles one:</p>
    <table>
      <tbody>
        <tr>
          <td>
            <code>$3190+x</code>
          </td>
          <td>Character Conversion Settings. 80+ will act like a normal DMA transfer.</td>
        </tr>
        <tr>
          <td>
            <code>$3191+x</code>
          </td>
          <td>VRAM target (low).</td>
        </tr>
        <tr>
          <td>
            <code>$3192+x</code>
          </td>
          <td>VRAM target (high).</td>
        </tr>
        <tr>
          <td>
            <code>$3193+x</code>
          </td>
          <td>Data location (low).</td>
        </tr>
        <tr>
          <td>
            <code>$3194+x</code>
          </td>
          <td>Data location (high).</td>
        </tr>
        <tr>
          <td>
            <code>$3195+x</code>
          </td>
          <td>Data location (bank).</td>
        </tr>
        <tr>
          <td>
            <code>$3196+x</code>
          </td>
          <td>Length of data (low)</td>
        </tr>
        <tr>
          <td>
            <code>$3197+x</code>
          </td>
          <td>Length of data (high)</td>
        </tr>
      </tbody>
    </table>
... Up to 10 slots, which means that the table will need 80 bytes.
<p><code>$317F</code> holds the number of used slots. If the number is 0xA (10), then all
slots are being used and no character conversion DMA will happen. To index the table
and enable the DMA, do this:</p><pre><code class="language-asm">SetTable:
	LDA $317F			; Load Character Conversion DMA slot count
	CMP #$0A			; \ if all slots are used, skip
	BEQ .End			; /
	ASL				; \ multiply the count by 8
	ASL				;  |
	ASL				; /
	TAX				; and use it as an index

	LDA #$SETTINGS			; \ Set $2231 value
	STA $3190,x			; /

	LDA #$VRAM_Low			; \ Set VRAM Destination address
	STA $3191,x			;  |
	LDA #$VRAM_High			;  |
	STA $3192,x			; /

	LDA #$BWRAM_Low			; \ Set	the BW-RAM address
	STA $3193,x			;  | (The pointer of the Bitmap)
	LDA #$BWRAM_High		;  |
	STA $3194,x			;  |
	LDA #$BWRAM_Bank		;  |
	STA $3195,x			; /

	LDA #$Length_Low		; \ Set the length of the transfer
	STA $3196,x			;  | (Size of the bitmap)
	LDA #$Length_High		;  |
	STA $3197,x			; /

	INC $317F			; Increase the number of slots used.
.End
	RTS				; Return
</code></pre><p>You will also need to learn how register <code>$2231</code> and SA-1 Bitmap work though.
Check out the SNES Dev. Book II, Super Accelerator (SA-1) -&gt; Character Conversion.
You may find the file on section "Links".</p></body>
</html>
